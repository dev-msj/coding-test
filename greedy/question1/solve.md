# 큰 수의 법칙

## 조건

* 숫자 배열을 M번 더하여 가장 큰 수 만들기
* 배열의 특정 인덱스에 해당하는 수가 K번을 초과하여 더해질 수 없다.
* 서로 다른 인덱스에 해당하는 수가 같은 수여도 다른 것으로 간주
* 입력받을 문자의 수: 2 < N < 1000
* 총 덧셈 횟수: 1 <= M <= 10000
* 연속 가능한 회수: 1 <= K <= 10000

## 풀이

* 가장 큰 수로 K번 더한 후 1번은 2번째로 큰 수를 더한다.
* 입력받을 수를 **정렬**하여 `max_value`와 `sec_value`를 찾는다.
* 정렬의 시간 복잡도는 **O(NlogN)**이다.
* 가장 큰 수로 K번 더할 수 있는 횟수는 `(M // K) * (max_value * K)`
* 2번째 큰 수로 더할 수 있는 횟수는 `(M % K) * sec_value`
* 알고리즘은 `(M // K) * (max_value * K) + (M % K) * sec_value`이며, **O(1)**의 시간 복잡도를 가진다.
* 이 풀이의 시간 복잡도는 **O(NlogN)**이다.

## 오답 노트

내 풀이에서 놓친 점은 문제에 작성되어 있는 `M > K`인 케이스만 보고 성급하게 일반화 알고리즘을 작성해버렸다는 것이다.
다른 엣지 케이스들을 함께 검증한 후에 적용하지 않았기 때문에 테스트가 실패했다.
`M <= 10000`이었기 때문에 굳이 일반화로 접근하지 않고 루프를 활용한 조건 검증으로 충분히 풀이 가능했다.
아직 역시 겉멋들게 접근하려 하기보단 단순하고 효율적으로 접근하는 것에 더 익숙해져야겠다.
