# 미로 탈출

* 시간 제한: 1 초, 메모리 제한: 128 MB
* N * M 미로
* 미로에서 여러 마리의 괴물을 피해 탈출
* 현재 위치는 (1, 1), 미로의 출구는 (N, M)
* 한 번에 한 칸 이동
* 괴물이 있는 곳은 `0`, 괴물이 없는 곳은 `1`
* 미로는 반드시 탈출 가능
* 최소 이동 칸의 수
* 첫째줄에 미로 정보: 4 <= (N, M) <= 200
* 다음 N개의 줄에 M개의 괴물 정보
* 시작 칸과 마지막 칸은 항상 `1`

## 풀이

* 최대 간선의 수: `m(n-1) + n(m-1)` -> `(200 * 199) * 2` -> `79600개`
* 최대 노드의 수: `n * m` -> `200 * 200` -> `40000개`
* 최대 경우의 수: `79600 + 40000` -> `119600` -> `O(E + V)`로 충분히 해결 가능
* 미로 탈출이므로 괴물이 없는 곳을 조사하며 앞으로 나아가야 함
* dfs는 stack 특성상 제자리로 돌아오는 경향이 있어 bfs가 적합
* 현재 좌표가 출구 좌표이면 탐색 종료
* 이동할 때마다 이동 칸 수를 1씩 증가

### 오답 노트

* 최소 이동 칸 수를 구하는 문제이므로 이동 칸수를 체크하는 것이 아니라 시작 지점으로부터의 거리를 체크해야 함
* 노드 실제로 방문을 해야 체크를 해야한다고 생각해서 queue에서 pop한 후에 방문 처리를 했는데, queue에 넣을 때 방문 처리를 해야 중복 방문을 막을 수 있음
* `while True`는 무한 루프의 가능성이 높아 위험함. 따라서 `while queue`를 활용하여 큐가 빌 때까지 반복하도록 해야 함
* 상하좌우 탐색 시 4개의 조건을 일일이 구현할 필요없이 델타 탐색을 활용하면 코드가 훨씬 간결해짐
* 델타 탐색이란 격자 그래프와 같이 상하좌우로 이동할 때 배열로 정의된 좌표 변화량을 iteration을 통해 탐색하는 기법

### 풀이 근거의 오류 개선

* 미로 탈출이므로 괴물이 없는 곳을 조사하며 앞으로 나아가야 함
  * dfs 역시 괴물이 없는 곳을 조사하며 나아가므로 근거가 될 수 없음
  * 개선: bfs는 레벨(거리) 단위로 탐색하여 **처음 목적지에 도달한 거리가 최단 거리임을 보장**하므로 최단 경로 문제에 적합함
* dfs는 stack 특성상 제자리로 돌아오는 경향이 있어 BFS가 적합
  * "제자리로 돌아옴"은 dfs가 최단 경로 문제에 부적합한 이유가 될 수 없음
  * 개선: dfs는 깊이를 우선으로 탐색하므로 **최악의 경우 가장 긴 경로를 먼저 탐색할 수 있어** 최단 경로 문제에 비효율적임
