# 상하좌우

* N * N 키기의 정사각형 공간
* 각 공간은 1 * 1 크기
* 가장 왼쪽 위의 좌표는 (1, 1)
* 가장 오른쪽 아래의 좌표는 (N, N)
* 상하좌우로 한 칸씩 이동 가능
  * L: 왼쪽
  * R: 오른쪽
  * U: 위쪽
  * D: 아래쪽
* 공간을 벗어나는 움직임은 무시
* 1 <= N <= 100, 1 <= 이동 가능 횟수 <= 100

## 풀이

N * N의 최대값은 10000이나 이동 가능 최대 횟수는 100이므로 사실상 최대 100번까지만 처리하면 됨.
그러므로 `O(N)`의 시간복잡도로 풀이해도 문제없다.

먼저 상하좌우의 움직임을 dict 형태로 정의한다.
중요한 포인트는 상단에서 하단으로 이동하는 공간이기 때문에 `U`이동이 마이너스라는 점이다.

```python
move_dict = {
    'L': (-1, 0),
    'R': (1, 0),
    'U': (0, -1),
    'D': (0, 1)
}
```

이후 최초 위치인 (0, 0)과 dict으로부터 받아온 이동 좌표값을 더하여 공간을 벗어나는지 확인 후 이동된 좌표를 현재 좌표로 변경하면 된다.

## 풀이 피드백

처음에는 list를 활용한 풀이를 생각했으나, 이보다는 tuple을 활용하는 것이 메모리적으로 더 효율적일 것이라고 판단하여 코드를 작성했다.
작성된 논리 로직은 적절했으나 "과연 이 방식이 최선이었을까"라는 의문이 들어 코파일럿에게 더 좋은 코드를 알려달라고 했다.
이에 대한 답변으로 훨씬 더 간단한 접근으로 가독성과 효율성을 모두 챙긴 코드를 알려줬다.

코드를 보면서 든 생각은 내가 코드 작성에 대해 너무 보수적으로 접근하지 않았나 싶었다.

* 좌표 자체를 하나의 세트로 생각했기 때문에 list나 tuple을 먼저 떠올리고, 변수를 활용할 생각은 못했다.
* `if-else` 구문은 가능하면 자제하는 것이 좋다고 알고 있었기 때문에, 이런 형식의 접근을 고려하지 않았다.

개발자는 **복잡한 문제를 간단하게 만들고 효율적으로 접근하는 것이 중요**하다고 알고 있다.
문제를 접근할 때 `어떻게하면 더 쉽게 해결할 수 있을까`를 먼저 생각한 후, 내가 알고 있는 방법론들을 적용하는 것이 좋을 것 같다는 생각이 든다.
