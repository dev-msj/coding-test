# 음료수 얼려먹기

* 시간 제한: 1 초, 메모리 제한: 128 MB
* N * M 크기의 얼음 틀
* 구멍이 뚫린 곳: 0, 칸막이가 존재하는 곳: 1
* 구멍이 뚫린 부분끼리 상, 하, 좌, 우로 붙어있는 경우 서로 연결되어 있는 것으로 간주
* 생성되는 총 아이스크림의 개수 출력
* 첫째줄은 N(세로 길이), M(가로 길이) 입력
* 다음 N개의 줄에는 M개의 정수(0 또는 1) 입력

## 풀이

* 0으로 연결된 곳은 1개의 아이스크림으로 간주
* 칸막이(1)은 아이스크림을 만들지 못함
* DFS를 사용하여 연결된 칸을 찾아 방문 처리가 완료되면 아이스크림 개수 1개 증가
* 처리 절차
  1. 각 칸을 노드로 간주하여 그래프 생성
  2. 특정한 지점의 주변 4칸(상, 하, 좌, 우) 확인하여 방문하지 않은 지점(0)이 있으면 탐색
  3. 방문한 지점에서 다시 주변 4칸을 확인하여 방문하지 않은 지점(0)이 있으면 탐색
  4. 2, 3번 과정을 모든 노드에서 반복하며 방문하지 않은 지점의 개수를 카운트

### 왜 맵 정보를 인접 리스트로 변환하지 않고 그대로 사용하나?

맵 구조는 **격자 구조의 특성**을 가지기 때문이다.

격자에서는 `(x,y)` 좌표의 상하좌우 `(x±1,y)`, `(x,y±1)`가 자동으로 인접 노드가 된다. 그러므로 인접 리스트를 찾아 변환하는 과정이 불필요하다. 또한 격자 구조에서는 맵 구조 자체가 그래프를 나타내는 2차원 배열이 된다.

   ```python
   # 인접 리스트로 변환한다면 (비효율적)
   adj_list = {
       (0,0): [(0,1), (1,0)],
       (0,1): [(0,0), (0,2), (1,1)],
       # ... N*M개 좌표 각각에 대해
   }
   ```

따라서 맵 정보를 2차원 배열로 사용하면 **O(1)**의 시간 복잡도로 `graph[x][y]` 노드의 연결 정보를 확인할 수 있다. 또한 방문할 노드 좌표도 인접 리스트 변환 없이 직접 계산할 수 있어 구현이 단순해진다.
즉, 이러한 격자 구조 문제에서는 **좌표 기반 탐색**으로 풀이하는 것이 인접 리스트보다 더 직관적이고 효율적이다.
