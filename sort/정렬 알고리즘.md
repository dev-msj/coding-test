# 정렬 알고리즘

> 데이터를 특정한 기준에 따라서 순서대로 나열하는 것

정렬 알고리즘은 선택 정렬, 삽입 정렬, 퀵 정렬, 계수 정렬 등 다양한 방법이 있다. 이 알고리즘을 통해 **알고리즘의 효율성**을 쉽게 이해할 수 있어서, 알고리즘 개론에서 자주 다루어진다. 상황에 맞는 적절한 정렬 알고리즘을 선택했느냐에 따라 프로그램의 성능이 크게 좌우될 수 있기 때문에, 이 학습을 통해 알고리즘 효율의 중요성을 깨달을 수 있다.

## 선택 정렬 (Selection Sort)

> 리스트에서 가장 작은 원소를 선택하여 맨 앞에 위치한 원소와 교환하는 과정을 반복하여 정렬하는 방법

```python
def selection_sort(arr):
    arr_len = len(arr)
    for i in range(arr_len):
        min_index = i # 현재 위치를 최소값 인덱스로 설정

        for j in range(i + 1, arr_len):
            if arr[j] < arr[min_index]:
                min_index = j # 더 작은 값이 있으면 인덱스 갱신

        # 최소값과 현재 위치의 값을 교환
        arr[i], arr[min_index] = arr[min_index], arr[i]

    return arr
```

위의 코드를 통해 알 수 있듯이 선택 정렬은 `N + (N-1) + (N-2) + ... + 2` 번의 비교 연산을 수행한다. 따라서 이는 `(N^2 + N)/2`로 정리할 수 있으며, 빅오 표기법에 따라 시간 복잡도는 <strong>O(N^2)</strong>이 된다.
선택 정렬은 구현이 간단하고 이해하기 쉬운 장점이 있지만, 다른 정렬 알고리즘에 비해 비효율적이다. 다만, 특정한 리스트에서 가장 작은 데이터를 찾는 일이 코딩 테스트에서 자주 출제되므로 이 알고리즘에 익숙해질 필요가 있다.

## 삽입 정렬 (Insertion Sort)

> 데이터를 하나씩 확인하며, 각 데이터를 적절한 위치에 삽입하여 정렬하는 방법

```python
def insertion_sort(arr):
    for i in range(1, len(arr)):
        for j in range(i, 0, -1): # i부터 1까지 감소하며 반복
            if arr[j] < arr[j - 1]:
                arr[j], arr[j - 1] = arr[j - 1], arr[j] # 자신과 바로 앞의 원소를 비교하여 교환
            else:
                break # 이미 정렬된 상태이면 멈춤

    return arr
```

삽입 정렬의 시간 복잡도는 최악의 경우 <strong>O(N^2)</strong>이지만, 이미 거의 정렬된 상태에서는 <strong>O(N)</strong>의 시간 복잡도를 가진다. 따라서 데이터가 거의 정렬된 상태라면 삽입 정렬이 매우 효율적일 수 있다. 따라서 거의 정렬된 상태로 입력이 주어지는 문제라면 삽입 정렬을 이용하는 것이 정답 확률을 높일 수 있다.

## 퀵 정렬 (Quick Sort)

> 기준 데이터를 설정하고, 그 기준보다 작은 데이터와 큰 데이터의 위치를 바꾸는 과정을 반복하여 정렬하는 방법

```python
def quick_sort_normal(arr, start, end):
    '''
    일반적인 퀵 정렬 구현

    추가적인 메모리 공간을 사용하지 않으나,
    코드가 다소 복잡하여 빠르게 파악하기 어렵다.
    '''
    if start >= end: # 원소가 1개인 경우 종료
        return

    pivot = start # 피벗은 첫 번째 원소
    left = start + 1
    right = end

    while left <= right:
        # 피벗보다 큰 데이터를 찾을 때까지 반복
        while left <= end and arr[left] <= arr[pivot]:
            left += 1
        # 피벗보다 작은 데이터를 찾을 때까지 반복
        while right > start and arr[right] >= arr[pivot]:
            right -= 1

        if left > right: # 엇갈렸다면 작은 데이터와 피벗을 교체
            arr[right], arr[pivot] = arr[pivot], arr[right]
        else: # 엇갈리지 않았다면 작은 데이터와 큰 데이터를 교체
            arr[left], arr[right] = arr[right], arr[left]

    # 분할 이후 왼쪽과 오른쪽 부분에서 각각 정렬 수행
    quick_sort_normal(arr, start, right - 1)
    quick_sort_normal(arr, right + 1, end)


def quick_sort_for_python(arr):
    '''
    파이썬의 장점을 살린 퀵 정렬 구현

    피벗과 데이터를 비교하는 연산 횟수가 증가하며
    리스트를 위한 새로운 메모리 공간을 할당하기 때문에
    비효율적일 수 있다.
    그러나 코드가 간결해지고 이해하기 쉽다는 장점이 있다.
    '''
    # 리스트가 하나 이하의 원소만을 담고 있다면 종료
    if len(arr) <= 1:
        return arr

    pivot = arr[0] # 기준 데이터 설정
    tail = arr[1:] # 기준 데이터를 제외한 리스트

    left_side = [x for x in tail if x <= pivot] # 기준보다 작은 데이터 리스트
    right_side = [x for x in tail if x > pivot] # 기준보다 큰 데이터 리스트

    return quick_sort_for_python(left_side) + [pivot] + quick_sort_for_python(right_side)
```

퀵 정렬은 분할 정복 알고리즘의 일종으로, 리스트를 분할하여 각각 정렬하는 방식으로 동작한다.
먼저 첫 번째 원소를 피벗으로 설정한다. 그리고 왼쪽부터 피벗보다 큰 원소를 찾고, 오른쪽부터는 피벗보다 작은 원소를 찾는다. 그런 다음 두 원소의 위치를 바꾸는 과정을 반복한다. 이 과정이 엇갈리면 피벗과 작은 원소의 위치를 바꾸고, 그 후에 피벗을 기준으로 왼쪽과 오른쪽 부분 리스트를 각각 재귀적으로 정렬한다.
퀵 정렬은 평균 시간 복잡도는 <strong>O(N log N)</strong>이다. 그러나 최악의 케이스에는 <strong>O(N^2)</strong>이 된다.
퀵 정렬의 핵심은 얼마나 균등하게 리스트를 분할하느냐에 달려 있다. 균등 분할 여부가 작업의 깊이를 결정하고, 깊이는 총 비교 연산 횟수에 직접적인 영향을 미치기 때문이다. 따라서 데이터가 무작위로 입력되는 경우 평균적으로 균등하게 분할되어 빠르게 동작할 확률이 높다.

### 최선의 경우 - 균등 분할

정렬되지 않은 8개 원소를 정렬한다고 가정해보자.

```plain
1단계: [8개] 전체를 비교하며 분할 → 8번 비교
2단계: [4개][4개] 각각 분할 → 4+4 = 8번 비교  
3단계: [2][2][2][2] 각각 분할 → 2+2+2+2 = 8번 비교

깊이: 3단계 (log₂ 8)
각 단계마다 N번 비교 → 총 N × log N = 8 × 3 = 24번
```

각 단계에서 "모든 원소"를 한 번씩은 봐야 하므로 단계마다 약 N번의 비교가 필요하다. 즉, 단계 수가 적을수록 총 비교 횟수가 줄어들게 된다.

### 최악의 경우 - 불균등 분할

이번엔 정렬된 상태의 8개 원소를 정렬한다고 가정해보자.

```plain
1단계: [8개] 분할 → 7번 비교 (1개 | 7개)
2단계: [7개] 분할 → 6번 비교 (1개 | 6개)
3단계: [6개] 분할 → 5번 비교 (1개 | 5개)
...
7단계: [2개] 분할 → 1번 비교

깊이: 7단계 (N-1)
총 비교: 7 + 6 + 5 + 4 + 3 + 2 + 1 = 28번 ≈ N²/2
```

이 경우 첫 번째 원소가 계속 피벗이 되어 한쪽만 반복적으로 처리하게 된다. 결과적으로 선택 정렬과 유사하게 동작하게 되어 효율이 매우 떨어진다.
